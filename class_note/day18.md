# Day18

연관관계 매핑

- 관계형 데이터베이스에서는 관련 된 데이터를 여러 테이블에 나누어 저장하고 조인을 통해 조회한다
  - 클래스를 만들 듯이 나누어서 저장한다
- 엔티티 역시 다른 엔티티와 관계를 맺고 있으며 참조변수를 통해 연간된 데이터를 조회할 수 있다
  - 테이블의 연관관계와는 다르다
  - 이것을 **패러다임의 불일치** 라고 한다
    - 지향하는 목표가 다르기 때문에 일치할수가 없다

단방향 연관관계 설정하기

- 우리가 직접 SQL을 제어하지 않고 엔티티를 제어하기 때문에 엔티티를 가지고 SQL이 생성되게하는것을 알아야한다
  - 엔티티를 가지고 테이블의 조인도 할수 있다
- 연관패밍 고려사항
  - 방향: 단방향과 양방향이 있다. **방향성은 객체에만 존재**하고 테이블에는 방향이 없다
    - 양방향이 되려면 서로의 엔테티참조변수를 가지고 있어야 양방향이 된다
    - 보드쪽에서는 멤버의 격체 접근할수 있지만 멤버는 접근할 수 있다
    - 하지만 테이블은 처음부터 양방향이다. 
      - 하나의 테이블처럼 붙어버리니까 방향성이라는게 없다
  - 다중성: 1:1 N:1 1:N N:N
    - 다대일이나 일대다가 가장 일반적인 구조이다	
      - 이것만 정확히 이해하고 매핑할수 있으면 다른것들도 사용할 수 있다
      - 1:1은 회원과 라커의 관계
  - 연관관계 주인(Owner) : 릴레이션 오너라고도 한다
    - 양방향 관계에서만 필요한 개념이다
    - 테이블은 어차피 양방향이기 때문에 객체에서만 존재하는 개념이다
    - 객체를 양방향으로 연관관계 맺으려면 한쪽을 연관관계 주인으로 설정해주어야 한다.

다대일(N:1) 단방향 매핑하기

- 데이터 모델링에서 다대일 관계가 가장 많으면서 기본이다
- 다대일 연관 매핑 조건
  - 게시판과 회원이 있다
  - 한명의 회원은 여러 개의 게시 글을 작성할 수 있다
  - 게시판과 회원은 다대일 관계다
  - 게시글을 통해서만 게시글을 작성한 회원 정보를 조회할 수 있다(단방향)
  - - 

연관관계 매핑하기

- **참조 변수를 소유한 엔티티쪽에 매핑에 의무가 있다**
  - 참조당하는 애는 그냥 가만히 있으면된다
- 참조하는애한테 @ManyToOne 달라지면된다
  - @JoinColumn을 통해 foreign key를 지정해준다
- Board 엔티티를 등록하면 멤버의 식별자 변수가 컬럼에 저장이 된다
  - 포린키가 자동으로 컬럼에 추가된다는 뜻인가?
  - 나중에 해당 포린키로 join하면 두개의 테이블을 한번에 볼수 있게 된다
- 실제로 변수가 늘지는 않지만 테이블에는 포린키가 입력되는것을 뜻하는 것 같다

@ManyToOne 속성

- opional : default가 true
  - 연관된 데이터가 없을수도 있다, 멤버가 null일 수도 있다
  - 이걸 false로하면 항상 member객체가 참조되어야 한다
- fetch : 끄집어내는 것 => 성능과 직결되는 문제
  - default가 EAGER 다(즉시 바로바로)
    - 보드정보를 셀렉했을때 연관된 객체는 1개이다
    - 이때는 같이 join해서 slect에 포함시키는 것을 말한다.
    - 매니트원에서는 참조관계에 있는 객체는 객체가 하나밖에 없기 때문에 같이가져와도 성능상에 문제가 없다
      - 하지만 원투매니에서는 여러개의 객체를 참조하고 있기 때문에 같이가져오면 성능상 문제가 발생한다
      - 회원 하나를 선택하면 여러개의 보드를 컬렉션 형태로 가지고 있는게 일대 다 형태이다
        - 그래서 얘들은 LAZY로 처리한다
    - 다대일관계에서도 LAZY로 설정할 때가 있다
  - LAZY : 참조하는 객체를 실제로 사용하려고 했을 때 조회하는 것

내부 조인으로 변경하기 (INNER JOIN)

- 아우터 조인은 join 조건에 포함되지 않은 게시글 조차도 조회결과에 포함시키는 것
  - 조인 조건을 만족시키지 못하는 조건들도 조회한다
- JoinColumn에 nullable =fale 하면 참조 변수가 비어있으면 검색하지 않는 것이기에 이너조인이된다
  - 성능상 이너조인이 좋기 때문에 그러헥 바꾸어준다
  - 콘솔창에 innerjoin이라고 찍힘



양방향 연관관계 매핑하기

- 보드와 멤버가 서로의 객체를 참조하고 있어야 한다
- 1:1의 양방향은 쉬운데 다대일 양방향은 어렵다
- N:1의 경우에는 N은 1개의 참조변수, 1은 List 형식의 참조변수가 필요하다

@OneToMany

- 멤버쪽에서 여러개의 보드를 참조하는 것 (하나가 어려개 바라보는 것)
- OneToMany는 fetch type이  LAZY가 디폴트이다
  - 리스트를 가져오려면 메모리가 많이들어간다



mappedBy 속성

- 양방향 연관관계에서 연관관계의 주인과 관련된 속성이다
  - 양방향은 반드시 연관관계 주인이 필요하다
- 객체는 참조변수가 2개인데 실제 테이블의 foreingKey는 하나이다
  - 이런 차이를 극복할 수 있는 방법이 필요했다
  - 둘중에 하나를 연관관계 주인으로 지정해서 foreingKey컬럼을 지정하는 것이다
  -  member_Id를 foreingKey로 하고 싶으면 Member를 연관관계주인으로 선언한다
    - Many쪽이 연관관계에 주인이 되는 이유는 forienKey를 가지기 때문이다
- 연관관계 주인은 Member엔티티가 아니라 Board엔티티에 참조변수 member가 주인이된다
  - Many쪽에 참조변수가 주인이 된다
  - 근데 설정은 주인이 아닌애가 나는 주인이 아니라고 설정한다 ㅋㅋㅋㅋㅋㅋ 복잡하네

- mappedBy는 양방향 매핑에서 연관관계의 주인이 아닌 쪽 변수에 선언한다
  - 우리는 boardList에 선언하는게 맞지. 왜냐면 member가 주인이니까

toStirng 순환고리 끊기

- 양방향 에 경우 서로의 객체를 참조 하기 때문에 toString 메서들르 사용하면 참조고리가 생긴다
  - 이때 한쪽에 @ToSTring에  exclude 속성을 사용하여 참조변수를 제외시켜야 이런 순환고리가 생기지 않는다

영속성 전이

- 특정 엔티티를 영속 상태로 만들거나 삭제 상태로 만들 때 연관된 엔티티도 같이 처리할 경우 영속성 전이를 사용한다.
- 도우너를 삭제하려면 도우너가 등록한 모든 글들도 삭제을 먼저 삭제하고 도우너를 삭제해야 한다
  - 이것을 자동으로 처리하는 것을 영속성 전이라고 한다
- 멤버가 인서트 될때 멤버가 가진 멤버들도 같이 인서트, 멤버 딜리트할때 멤버가 가진 보드들도 딜리트하기
- OneToMany에 cascade=CascadeType.ALL)  속성을 통해서 할 수 있따



정리

- Repository 인터페이스 만들기
- Service(사용하는 곳)에서 @Autowired 통해서 DAO처럼 사용하기
  - 인터페이스니까 내부적으로 클래스객체 생성해서 넣어주는것이다



쿼리 DSL

- 마이바티스에 다이나믹 쿼리랑 비슷하다
  - 마이바딕스에서 if문으로 사용했던 다이나믹 sql 찾아보기
- SQL을 JAVA코드로 타이핑 하는 것이 특징이다
  - 컴파일전에 확이할 수 있어서 좀더 안전한 쿼리문 작성할 수 있따

- 실습
  - 디펜던시추가- 플러그인 추가
  - 리프레쉬하고 메이븐 업데이트하면 src/main/querydsl 폴더 생긴다
  - public interface DynamicBoardRepository extends CrudRepository<Board, Long>,
    											    QuerydslPredicateExecutor<Board> {
  - BooleanBuilder는 동적 쿼리를 만들어주는 객체
- 



웹으로 넘어오기

- 스프링 부트웹 프로젝트만들기
- jsp 디펜던시 추가
  - 부트에서는 jsp 를 사용하지 않고 타임리프를 사용한다
    - html로 동적으로 출력할 수 있다
      - 템플릿 엔진이라고 한다

- 어플리케이션.프러퍼티스 수정
  - 뷰리졸버는 자동설정으로 객체 생성된다
    - 우리는 프로퍼티로 값만 넣어주면된다(그거 db할때 했던 예제)
    - 저 프로퍼티 명따라서 입력이 되겠지
- src/main 밑에 webapp 폴더 만들어주고 webapp폴더로쓰기
- com.rubypaper.domain
- com.rubypaper.controller
- jsp

이걸 왜하냐

- jpa랑 웹을 어떻게 연동하느냐
- 스프링부트에서 jsp를 이용해서 개발할 수 있다

- spring.thymeleaf.cache=false
  - 타임리프..그거 동적으로 업데이트
- 스프링 시큐리티도 필터이용해ㅅ한다













