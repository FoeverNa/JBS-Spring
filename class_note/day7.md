# day7

**STS 설치해놓기**

**어제복습**

- 스프링 사용하는 의미는 아키텍처를 위해서 사용한다
  - 아키텍처는 프로그램에 뼈대이다
  - 어제 배운 MVC 가 아키텍처이다
- MVC에는
  - controller
  - view
    - jsp파일로 디자인만 들어있다
    - 다른 기능들은 절대 jsp가 가지고 있으면 안된다
  - MVC로 개발해라 라는 말은 이러한 명확한 기능들이  이미 명확히 규정되어있고 그것안에서 구현하는 것
- 프레임워크의 의미
  - 아키텍처에 해당하는 뼈대, 골격을 제공한다
  - 반제품, 실질적인 비지니스 로직은 (디비연결로직, 사용자 정보추출 ) 제공하지 않는다
    - 구체적인 로직은 개발자가 추가해주어야 한다
- Java 프레임워크 종류
  - 오픈소스 , 장점은 커스터마이징 할 수 있다는 것
  - 어떤회사도 그냥 스프링프레임워크를 사용하지는 않는다
    - 스프링프레임웤을 커스터마이징해서 우리회사만에 프레임워크 만들수 있다
- 스프름 프레임워크의 특징
  - POJO - 클래스만드는데 제약이 적은 클래스
    - 메모리사용양이 적다
    - 반대로 서블릿 같은 클래스는 메모리사용량이 많다.(기본적으로 생성되는객체가 많다)
  - 컨테이너
    - 컨테이너는 설명하기가 어렵다
    - 하지만 서블릿엔진에서 경험했듰이 필요한 객체를 로딩해서 필요한곳에 샥샥넣어준다
    - 이런 기능을 역제어라고 한다
      - Inversion of Control
      - 제어를 역방향으로 한다는 것
      - 객체 생성에 주체가 개발자가 아닌 컨테이너가 하는 것
        - 역제어 컨테이너라고 한다
      - 자바소스 수정 없이 유지보수를 할 수 있어서 유지보수에 유리하다
    - 순제어
      - 우리가 객체가 생성하는 것이 순제어
      - 유지보수할때 내가 소스를 수정해야 한다
        - 유지보수가 어려워진다
    - xml을 읽어드리자마자 객체들을 프리로딩 한다
      - 등록된 순서로 메모리에 올라간다
    - 디폴트 생성자가 필요하다는 것까지 설명



**새로운내용**

- 객체 생성시 자동으로 id가 생긴다(콘솔창)
  - 패키지.클래스이름#num이 붙는다
- 왜 id가 중요한가?
  - 참조변수로 객체를 활용할 수 있듯이 컨테이너가 생성해준 객체를 구별할수있는 방법이 필요하다
- 근데 id가 기억하기가 어렵다 그래서 id속성이필요하다
  - id 3개만들어서 하나하나 넣어줄수있다
  - id가 같으면 에러가난다
- 근데 이것도 안쓴다?
  - tv로 하나만들고 tv이름만바꾼다
- sts필요한 이유설명하셨다
  - 편하게 xml을 작성할수있게 도와준다
  - new other 하면 spring springboot 생긴다
- 여기까지가 역제어 컨테이너에 기본
- 스프링은 커테이너이고 자바 객체이다.
- Spring 컨테이너의 동작 
- 컨테이너는 맵하나를 가지고있는 것
  - 맵에 tv라는 key에 객체를 가지고있는것
  - 그외에 xml에 작성된 것 객체도 맵에보관하는것

**xml파일***

- 왜 중요한가? 컨테이너가 xml을 로딩하여 그것을 바탕으로 운영된다
  - 우리는 xml을 통해서 스프링컨테이너를 제어할 수 있다
- 뼈 - 프레임, 살은 비지니스로직, 
  - 뼈는 jar형태에 라이브러리에 다들어있다
    - jar파일 하나안에 많은 패키지 와 그안에 또 많은 클래스들이 존재한다
    - 이걸 프레임워크가 제공하는 것이다
- 살 - 비지니스로직, 
- 뼈를 준비하고 살을 만들었으면 붙여줘야될거아냐 그게 xml환경설정파일이다
  - 연결고리, 접착제 역할
- 스프링 컨테이너는 스프링이 제공한다
  - 얘는 jar파일안에 있겠지
  - 내가 만든 클래스를 넘겨주는건 누가하냐? xml파일
    - xml파일을 통해 설정을 통해 동작이 달라지게 된다
- 오늘 수업핵심은 xml 설정을 어떻게 하느냐



- xml파일 보기
  - bean xmlns - 이름공간, namespace
    - xml에서 사용할 수 있는 태그으 이름을 모아놓은것
    - xsi schemaLocation에 있다
      - 브라우저 클릭해서 보기
      - top-level 은 beans래
        - description : 주석
        - import : xml에 로딩하는 수간 같이 로딩 할 파일을 지정해줌 /ex other.xml
        - alias : 별칭을 붙여주는건데 가독성떨어져서 안쓰는게좋다
        - bean 
        - 4개 태그밖에없다고 써있다
          - 꺽쇠하고 기다리면 4개만 뜬다
          - 근데 우리가 알건 bean과 import만 알면된다
          - jstl과 비슷핟
- ben태그가 중요하다
  - id는 필수가 아니고 class는 필수다
    - 근데 id를 등록하는게 도움이된다
- 변수를 초기화하고 싶으면 어떻게 할까?
  - 컨테이너는 기본 생성자로만 객체를만든다
    - 파라미터 생성자있어도 사용을 안한다
  - 멤버변수 초기화하는 메서드만들어도 실행안시킴
    - xml를 수정해줘야 컨테이너가 인식한다
    - 서블릿에 init메서드와 비슷하다
    - init메소드 destroy 메소드 사용할수있다 (메소드 이름은)
    - 종료까지하는거확인하기
- id속성과 똑같은 name속성 있다
  - id는 제약조건이 있다 
    - 숫자로시작 x
    - 특수문자x
    - 공백x
    - 마치 자바의 변수이름과같이
  - name은 자바변수명 규칙을 따르지 않는다
    - 특수한 id를 등록할때는 name쓰지만 일반적으로 id를 사용한다
    - 아이디에 스페이스가 많으면 getbean하기가 어렵다
      - *실제 해보니 공백이 어떻게 적용되는지잘모륵렜다*
- lazy-init
  - 기본적으로는 프리로딩이지만 lazy-init 속성으로 레이지 로딩할 수 있다
    - true가 레이지, false는 프리로딩이다. 
    - default가 false이다.
- 스콥
  -  순제어의 가장 큰 단점은 내가 new할때마다 메모리가 생성된다 -> 메모리낭비
    - 하나만 생성되고 만약있으면 주소만 복사하는게 효율적이다
    - 그래서 싱글톤 패턴을 사용한다
      - 근데 문제가 있다
      - 클래스가 많아지면 귀찬아진다
  - tvuser에서 getbean 3번해서 tostring해보기
    - 하나의 객체를 사용하고 있음을 알고있다
    - 생성되는시점은 컨테이너 생성시점
    - getBean은 생성하는게 아니라 주소만 주는것
      - 서블릿과 비슷하다
  - scope="singleton"속성 주어도 똑같다
    - default가 싱글톤이구나
    - ="prototype"으로 하면 getbean할대마다 생성해준다
      - 거의 쓸일은 없는데 사용된 것만 이해할수있으면 된다

- 의존성주입(Dependency Injection)
  - 객체지향 언어는 클래스가 많다
  - 왜많은가?
    - 티비가 스피커까지 다하면 기능이 집중이되있다고 판단해서 불리함
    - 기능의 세분화
  - 객체와 객체 간의 관계가 생성이 된다
  - sonyspeaker 어디서 생성할것인가 문제발생
    - 유지보수에 관점에서 생각해야한다
    - 아 빈으로했으면 더좋았겟다
    - 새로운 파라미터 생성자만들기
      - constructor-arg 에 ref로 id로 speaker 해줌
      - 그위에 새로운 bean 만들어서 id를 speaker로 해서 넣어줌
        - speaker와 파라미터가 맞아야 한다
      - 그럼 생성자가 sonyspeake를 받을수 있는애를 아규먼트로해서 넣어줌
        - 파라미터 생성자에 넣어줌
  - IOC중에 DI가 젤중요한데 2가지 방법이있다
    - 생성자 인젝션, 세터 인젝션
  - Depednccy Lookup은 getBean이다
    - DependecyLookup은 쓸일이 없다.. injection을 바라
  - DependecyInjection
    - 애플 스피커 만들어서 교체하기
      - 에러가 왜날까
    - 포인트는 자바코드 수정하지 않고 교체할 수 있는 환경만들기
      - Speak 인터페이스 만들어서 다형성으로 넣을수있게해준다
        - 객체 생성 없이 speker를 넣어주면된다.  => 아까부터 그렇게햇어야됬는데 햇갈린부분
    - 하나의 스피커를 여러개의 TV가 사용한다. 하나의 TV를 여러개의 클라이언트로 사용함
      - IoC가 가져간 제어가 무엇이냐(개발자로부터)
        - 객체 생성
        - 객체간의 의존관계
      - TV도 맘대로 맘대로 바꾸고 스피커도 맘대로 바꾸는데 자바소스를 하나도 안했다
  - 삼성tv에 prive변수 추가
    - price 초기화ㅏ 하기 위해 constructor-arg 추가, ref는 참조, value는 값을 입력할대쓴다
    - 이상태로 실행하면 3번째
  - 여기까지 끝 

​	

- 세터로 인젝션하는거
  - name speaker는 setSpeaker를 의미한다 ref speaker는 id Speaker라고 한다
    - 문법이 setsetSpeaker될 수 있다
  - value로 해서 또 넣어준다
  - 정리하고가기
    - 의존 관계
      - 삼성tv가 Speaker를 참조해야하는 것. 이게 의존관계
      - 중요한건 다른 speaker로 교체할수있다는것
      - constructor-arg 태그를 사용하는게 생성자주입
    - 생성자 vs 세터 차이?
      - 성능, 결과가 똑같다 하지만 100% 세터만 쓴다
      - 변수별로 생성자를 만들어주어야 한다
      - 세터는 세터만 만들어 놓으면 된다!
  - xmlns:p="http://www.springframework.org/schema/p" 추가하기 
    - p name space라고 한다
    - p:으로 property줄여쓸수있다
      - -ref가 붙으면 참조이고 안붙으면 value속성으로 넣는것
      - 라인수를 줄여주어서 컨테이너가 읽어드리는 시간을 줄여주는것
        - 근데 잘안쓴다.. 가독성이 떨어진다

- Annotation 설정

  - 스프링 IoC컨셉은 자바소스 건들지 말고 xml만 수정하면서해라

  - 근데 xml이 500줄이면 얘를 유지보수하는게 더어려워질수가있다

  - context추가

    - 전혀 다른 명령을 추가해주는 것

  - context:componantscan만 기억하라

    - comp를 apple과 lg에 붙여봐라 

  - Polymophism4 패키지중에서 @Component가 붙은애들을 찾아서 메모리에 띄워라

    - 클래스위에 붙여줘야한다

  - Component = <bean class="polymorphism4.LgTV"></bean>

    - 근데 id가 빠졌다
    - 이러면 기본형 아이디가 id lgTV로 만들어진다(클래스이름에 첫글자를 소문자로)
      - bean에 아이디랑은 다르다

  - 그럼 id를 어떻게 줄것인가?

    - @Component("tv")로주면된다

  - lg에 apple넣어주기

    - 어노테이션으로 생성하면 무조건 기본생성자이다.

      - 생성자, 세터 둘다 안스고하고싶다(xml 설정안하고 싶어~)

    - Autowired로 해결할 수 있다.. 아따 편하네

      - 넣으려고 하는데 메모리에 객체가 없으면 에러가 발생한다

      





