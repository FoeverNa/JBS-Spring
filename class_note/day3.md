# day3

- 검색 상세조회할때마다 조회수를 1증가시키기

  - Update_CNT 변수만들고 따로 CNT 메소드만들어서 getboard에 넣으면된다
    - 하지만 여기서만사용할것이기에 핵심 코드만 그냥 복사해넣고 메소드 지우기

- user - UserVO클래스 생성

  - @Data
  - private 변수 선언

- BoardDAO 클래스 복사 - user패키지로 복사

  - User에 맞게 변경

  - insert와 get만 남기고 변경

  - vo에 맞게 메소드 수정

    

- userTest로 와서 등록하고 get해보기

  - id가 primarykey이기에 같은값입력하면 실패한다
  - get의 결과는 클라이언트가 어떻게 할지 결정하게 해야한다
    - 로그인실패 성공
    - ~의 권한을 보여줄수도있다

- JDBC 마무리~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - boad와 user를 join한다고 가정하고 id, password
    - 로그인해서 특정회원이 작성한 글만 뿌러줘야함
    - boad에 뭐가있어야되나 -회원 아이디가 foreing key가 있어야 된다
  - JDBC 프로그래밍 절차는 외워라



- 이클립스 콘솔 - 서버 분리해서 보기

- HTTP
  - HTTP프로젝트 생성
    - webContent에 모든 웹관련 파일이있다
    - web.xml열기 - soruce보기
  - src - new - servlet
    - hello/HelloServlet
      - 클래스이름이 Servlet으로 끝나면 서블릿으로약속이되있다
      - 이름은 Servelt 띠고 첫글자는 소문자로 바꾼다 h
      - 그럼 URL mappings 도 /hello로 바뀐다
        - 더블클릭하고 .do를 붙인다
          - do는내맘이래
        - 반복해서 해봐야 익숙해진다\
      - ok누루면 xml이 수정되고 Sevelt도 탬프릿이 자동으로 추가가 되어있다
  - servlet 보기
    - 디스크립션 디스플레이 네임은 지워도된다
    - /hello.do 라는 url을 주면 이름이 hello인 hello.HelloServlet을 열어주어라
  - Helloservelt 클래스로가기
    - 주석다지우고 메소드들 내용 추가해주기
  - server . add/remove -> add해서 configured 로 이동
    - 톰캣서버가 이프로젝트관리할 수 있음
    - 다니아믹 웹프로젝트로 되어있어야 톰캣에 등록할 수 있다
      - 목록에뜨지도안음
  - 톰캣서버시작
    - 이클립스에 지구본 모양 누루면 웹브라우저 클릭하고 주소치기http://localhost:7777/HTTPProject/hello.do
    - 아니면 helloSevelt에서 실행하면 브라우저뜸
    - window - webbrowser - 4.Chrome으로 만듬
    - 크롬브라우저로 뜬다

- 엄청나게 중요한 설명

  - 톰캣은 자바로만든 서버
    - Tomcat 서버로 생성할 수 있다
    - 톰캣서버 구동하는순간 톰캣 객체가 생성이되면서 로그가 출력된다
      - 객체가 생성되는과정에서 로그를출력하는건어렵지안다
    - 카탈리나는 톰캣에 또다른 이름
      - Starting service Catalina까지가 실행된것
    - 톰캣이 잘생성되면 Servlet Engine이 새생성됨
      - Servlet Engine도 톰캣에 클래스중에하나
  - 왜 웹이 어렵냐 서버, 웹 브라우저 를 내가 안만들어그렇다
    - 브라우저에 기능과 서버에 기능을 어느정도는 이해하고 들어가야한다
    - 서버가복잡하니 이것먼저하자
  - 다시
    - 톰캣실행시 내부버적으로는 ne Tomcat() 하고 객체 생성됨
    - Strating service Catalina가 톰캣이 생성된것
      - new ServletEngine() 이 생성되는것 
        - 얘는 톰캣이 생성해준다.
        - 얘생성될때 web.xml이 전달된다 -> 그래서중요한 것

  

  - HelloServlet 을 웹브라우저 요청하면 객체가 생성됫다고 뜸

    - 클래스왜만드냐 객체 생성하려고.
    - 왜메서드를구현하냐? 내가호출해서사용하려고
    - 근데 웹브라우저에서 hello.do요청하면 객체생성하고 메서드를 호출해줫다

      - 그럼 누가 해준거냐? 
      - 톰캣서버 좀더정확하게 서블릿엔진이 객체생성과 메서드 호출을 같이 해준것
    - 이제는 발상전환해주어야함

      - 지금까지배운거랑은 차원이 다르다

      - 객체생성하려고 클래스를 만드는데 

        - 오늘부터배우는 웹기술은 나는 클래스만만들뿐 서블릿 엔진이 객체를 만들고 메소드호출한다
        - 다만 우리가 개입할수있는건 서블릿엔진에게 web.xml을 통해 소통할수있다

        - web.xml에 오류발생시키고 톰캣키면 톰캣은 구동되고 서블릿엔진은 실행이안됨
          - sevletenge이 xml받는다는증거
    - 서블릿은 자바기술이 맞지만 우리가알고있는 거랑은 다르다

      - 서블릿은 톰캣서버 없으면 실행할 수가 없다
      - hello.do라고 해야 서블릿엔진이 반응 왜? web.xml에 약속되있어서

- https://en.wikipedia.org/wiki/Apache_Tomcat





HTTP 프로토콜

- 프로토콜은 약속이다.,

- 두회사가 어떤형식으로 보낼지 형식을 약속했어
  - 그렇게해서 서로 데이터를 잘 주고받을 수 있어
  - 만약 바꾸면 여러회사가 프로그램을 수정해야한다
- 그래서 프로토콜은 한번에 잘만들어야되고 수정하면 안된다

- 웹클라이언트에서 웹서버로 요청을 보내면 http프로토콜을 보낸다
  - 서버는 그 프로토콜정보를 해석해서 실행하고 다시 응답프로토콜을 보내주면 서버가 보내준 응답프로토콜을 해석해서 실행결과를 디스플레이해주는것
  - 이게 웹 클라이언트 서버에 통신이다
- HTTP Response Http Request 가 있는데 형식은 같다
  - StartLine - Message HEader- CRLF(공백) - Message Body
  - 모든 브라우저는 동일한 방식으로 작동한다. 
    - 뭔가 클릭하는 순간 요청 프로토콜을 만들어서 전송하고 서버에서 해석해서 뭔가해서 응답 프로토콜을 만들어서 흘러흘러 보면 브라우저가 해석해서 화면정보를 출력한다
  - 서로 상대적이다. 내가 서버면 클라이언트에 요청을 기다린다. 
    - 요청오면 바로바로 해버려, 응답프로토콜을 막채워서 보낸다
    - 서버는 무한루프돌면서 브라우저 요청 프로토콜 받고 응답해주고 
    - 반대로 브라우저는 요청프로토콜보내고 서버가 보내준 응답프로토콜을 해석해서 출력해준다

- 실습

  - webcontent - newfile -html - login.html - next - 4.01선택

  - html문 작성

  - 실행해서 확인

  - localhost:8080/HTTPProject/login.html로 접속한다

    - localhost대신 ip입력하면됨
    - localhost:8080까지하면 톰캣까지연결되는 것, 톰캣이 관리하는 HTTPProject에 들어가서 html파일 받겟다
    - 엔터를 빵친 순간 크롬브라우저는 요청프로토콜을 만든다
      - 브라우저가 서버쪽에요청할수있는 3가지
        - url 요청
        - 버튼 클릭
        - 링크클릭해서 요청
      - 그럼 요청프로토콜 만든다

  - 요청프로토콜

    - Start line

      - 요청방식 : GET POST 방식 두가지

      - URI : 포트번호뒤를 URI라고 한다 -> 이게 맞나?

      - 대부분 GEt방식이고 폼에 있는 것만 Post라고 하면된다

      - 프로토콜 HTTP1.1은 프로토콜인데 변하지 않아서이라 크게 중요하지 않다

        

    - Message Header

      - 브라우저 서버만 아는거라 안중요

      - 키벨류쌍

      - Accpt : 서버로부터 받을수있는 파일 종류

        - 등록되지 않은 새로운파일 전송되면 다운로드창 띄워버린다(처리못하니까)

      - Accept-Language:ko 

        

    - Message Body

      - 사용자가 입력한 정보는 여기에 딸려간다
        - 요청 방식이 POST일 때만
      - 실습 -> 로그인하면  URL뒤에 물음표해서 사용자 id 값과 password 가 보인다.
        - get방식이기 때문에.
        - Body에는 값이 담기지 않는다
        - 네이버 검색하는것 ?뒤에 표시된다
          - 외부에 공개되도 괜찬은것만 Get쓴다
      - 요청방식을 post로 바꾸어서 다시해보기
        - 보이지 않는다
        - Body에 은닉되서 전달된다

    

    - 응답프로토콜

      - 서버가 만든다

      - startLine

        - 프로토콜 이름및 버전

        - 응답상태코드(중요)

          - 다양하고 복잡함

          - 404

            - fileNoFound
            - 서블릿엔진은 해당 url을 처리할수있도록 web.xml 되어있다
              - .do 요청은 web.xml 에 등록된것만 처리해준다.
              - 다른 .do하면 404가 뜨게된다

          - 405

            - hello.do로 바꾸니 post방식으로날리니 doPost가 호출이 된다

              - get방식으로 바꾼뒤 날리니 doGet이 호출된다
              - 요청방식에 따라 실행메소드가 달라진다

            - 서블릿클래스가서 doPost 주석하고 다시 post로 요청하면 405가 뜬다

              - 서블릿 엔진이 서블릿 객체생성해주는데 요청을 하면 리로딩(수정됬으니 생성해주는것)
              - doPost가 없기 때문에 MethodNOtFound 
                - post is not supoorted
              - 서블릿이 요청방식에 따른 메서드 가지고 있어야 한다

            - 

              

          - 500

          - 서블렛클래스가서 dopot 주석 풀고 sout(9/0); 작성-> arithmeticException 발생

            - 이때 500이 뜨게 된다
            - 500은 Internal Sever error고 예외가 발생했다는것
            - 예외메세지도 브라우저에 표시된다/ 콘솔에도 표시된다

            

        - 응답상태코드 메세지

      - Header

      - Body

        - 브라우저가 요청한 문서(이미지, 엑셀)가 body쪽에 담겨서 전달이 된다
          - 브라우저에 주소넣고 엔터딱치면 브라우저가 GET방식으로 uri로 채우고 다채워서 서버로전달
          - 서버는 startline추출해서 어떤방식으로 어떤파일원하는지확인
            - 만약 파일이없으면 body지우고 상태코드에 404해서 보내면됨
            - 파일있으면 상태코드에 200 세팅하고 body에 문서를채워서 보냄
          - 브라우저는 body에서 html코드 받아서 그려주는게 로딩된 화면
          - 

  서블릿

- 서블릿 특징

  - 서블릿은 자바 클래스이다
  - 서블릿엔진에 의해서만 사용될 수 있다(객체 생성, 메소드 사용)

  - 플랫폼 독립성
    - 자바의특징
  - 서버 독립성
    - 서블릿규칙에 맞게 작성이되면 톰캣외에 다른 서버에서도 구동이가능하다
    - 위에 두가지가 이식성을 엄청좋게해준다
  - 확장성
    - 외부 벤더에서 제공하는 라이브러리 사용가능하다
  - 멀티스레드 - 굉장히중요
    - 멀티스레드로 동작하기 대문에 웹 환경에서 매우 효율적이다
      - 멀티스레드로 동작 시키는 것은 개발자가 할일이 없다 - 서블릿엔진이해준다
  - 서블릿 수행흐름
    - ㅇ톰캣실행 -> web.xml 읽어드려 서블릿 엔진가동
    - 그림에 없는 스레드 풀을 서블릿 엔진이 생성된다
      - 풀은 객체가 저장되어있는 공간
    - 스레드객체 하나를 할당받아서 두갯이나 두포스트를 하게 된다
      - 이스레드 작업을 누가했냐 내가아님~
    - 지금부터는 서블릿 클래스 문법이해하고 라이프 사이클이해하면된다

서블릿 클래스 문법(서블릿 규칙)

- 1번 HttpServlet 클래스를 상속해야 한다.
- 2번 public 클래스로 만들어야 한다.
  - 서블릿에서 접근하기 위해서
- 3번 dfault 생성자가 있어야 한다
  - 생략되어있으니까 구지 안써줘도 되긴하다
- 4번 요청 방식(method)에 따라 doGet이나 doPost를 재정의(Overriding)한다
- 5번 부모(HttpServlet) 클래스의 메소드를 재정의 하지 않으면 상속받는다



- 수동으로 클래스로 만들수 있다
  - web.xml도 수동으로 써줘야 한다

라이프 사이클

- 여러메소드 오버라이드

- 서버끄고 다시 hello.do 부르기

- 생성하고 이닛하고 서비스 호출

  - 서블릿엔진이 다해준다
  - 디스토리 어덯게든지잘모르겠네

- 브라우저가 요청할때마다 서블릿객체가 생성되면 서버다운된다

  - 서블릿 엔진이 서블릿객체 단하나만 생성한다

- 라이프 사이클 그림

  - 첫번째브라우저가 요청하는 서블릿 메모리가 존재하는지 찾아봄
    - 없다면 헬로 서블릿.클래스파일 찾아서 메모리로딩한다
    - 디폴트생성자 호출해서 서블릿객체가 메모리에 뜬다
      - 매개변수가 있는 서블릿생성자는 인식을못함
    - 디폴트생성자밖에 안되서 멤버변수를 디폴트로밖에 초기화 못하는 문제 발생
      - 그래서 init()생김 -> 멤버변수 초기화역할
      - 오버라이딩안하면 init메서드는 아무것도 안함
    - 스레드 풀에서 스레드 객체 하나가 나오면 그스레드가 서블릿 객체에 서비스 메소드를 호출한다
      - 스레드 객체가 런메서드가 실행하는데 서블릿에 서블릿 메서드만 실행시킨다
        - 서비스 메서드는 GET이면 doGEt elsif POST면 doPOST해라(오버라이드 안할시)
          - 서비스도 요청을 분기처리하게 되어있을뿐이다. 
  - 두번째 브라우저가 똑같은 hello.do를 요청하면 객체가 존재하면 스레드가 하나더 나와서 서비스실행하게된다
    - 그래서 첫번째 실행은 느리다. 그래서 서비스만들고 첫번째 돌린다

  - 파일위치는 외우면 좋다

















