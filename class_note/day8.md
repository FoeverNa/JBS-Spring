# day8

**어제 복습**

- IOC
  - Inversion of Control
  - 제어의 역전, 역제어
  - 객체에 대한 생성과 관리의 주도권을 누가가지고 있는가
    - 개발자가지고 있으면 순제어
      - 유지보수가 어렵다
  - 컨테이너가 2가지를 제어한다
    - 객체 생성
    - 객체 간의 의존관계
      - 운영상에 변경될수가 있는데 그것을 XML수정으로 할수있다
        - IOC의 핵심
  - 컨테이너에게 지시하려면 xml을 통해서 할수있다
  - 2가지종류
    - Dependency Lookup
      - 컨테이너에게 찾아달라고 하는것
    - Dependency Injection
      - 생성자 Injection
        - constructor-arg가 없으면 default 생성자로 생성
        - 있으면 해당 객체를 생성해서 넣어줌
      - Setter Injection
        - poperty를 활용해서 name은 setter메서드명, ref는 참조 id
        - 세터는 장점이 있다
        - 세터만 만들어도되는
        - p네임스페이스 사용
          - property를 더짧게 사용할 수 있는 네임스페이스다
  - Annotation
    - name space를 추가한다는 것은 다른종류의 명령어를 사용할 수 있다는것
    - context:component-scan base-package="패키지명"> 패키지명에 있는것을 컴포넌트로 스캔해라
      - 이제 componnent 어노테이션만 사용하면된다`
      - ()열면 id를 등록할 수 있다
    - type injection:Autowired

**오늘내용**

- 프레임워크통해서 개발하면서 가장힘든것은 에러메세지를 읽기가 어렵다
  - 골격을 이루는 클래스들에서 발생하는 에러들을 내가 알수가 없어서 어렵다
- 에러 메세지 맨아래에 있는애를 보면 된다. 걔가 원인이 된다
  - 마지막 exception찾기

- AppleSpeak를 SonySpeaker로 바꾸어주고 실행하면 예외 발생한다.
  - autowired에 찾는 타입이 없어서
  - **인텔리제이에서는 빨간줄을 그어주네**
- sonySpeaker에 @component("sony")하면 해결된다
  - 아니면 componnet지우고 bean등록을 해주어도된다
  - bean등록하면 xml수정해야되서 불편하다
- 스피커를 변경하는 과정에서 자바코드를 변경하면 안좋은 방법이다
  - 컴파일을 다시해야한다
- Sepake 인터페이스를 사용한다
  - 실행하면 unique하지 않다고 예외 뜸
  - 2개에 빈중 뭘 해야될질 모르겠어서 한다
  - 주석을 막고풀면되는데 걔도 소스를 변경하는거라안된다
- 스피커에 컴퓨넌트를 지운다
  - 실제로 사용할 speaker 타입의 객체는 하나만 등록해놓는다
  - xml설정을 최소화 하는게 목적이지 xml을 사용하지 말자는 뜻은아니다
    - 모든걸 다 어노테이션으로 할수가 없다
    - 결국은 xml+어노테이션을 사용하게 된다
- 내가만들지 않은 라이브러리는 어노테이션 달수도 없기 때문에 빈등록을 해야한다
- 내가만든 클래스라도 유지보수중에서 바뀌지 않는애들은 어노테이션으로 한다
  - 자주 바뀌는 클래스는 빈등록을 해서 얘만 변경하는방향으로 가는게 좋다
  - TV도 자주바뀐다면 컴포넌트 붙이면 안된다
    - 얘는 룩업을 해야되는애라서(getBean) id도 붙여줘야 한다
- @Resource
  - @Autowired대신 사용될수있는 어노테이션
  - Resource는 name속성을 이용할수 있다는 장점이 있어서 사용한다

- 새로운 실습 준비
  - xml파일, dao 가져오기
- BoardService 컴포넌트
  - 클래스다이어그램 보기
  - 4개의 .java가 세트다
  - 테이블당 하나씩 필요하다
  - 테이블이름이 앞에온다
  - 1,2, Vo DAO 만든다
  - 3,4 가 sevice 인터페이스 서비스 구현체
  - 이런다이어그램주고 만들라고하면 만들면된다
  - vo는 컬럼넣고private하고
  - dao는 crud넣는다
    - 독립된 클래스로 만들어야 한다
  - interface는어떻게 만들어?
    - dao에서 extract interface해야됨
      - 이때 dao에 implements는 지워야함
  - 구현체 만들기



- 테스트 만들어서하기
  - id를 getBean으로 lookup하기때문에 service는 해주어야 한다
    - 안바꾸면 클래스명에 앞에만 소문자로바꾸어서 id생성됨
  - 

- Layer 별 Annotation
  - component에 기능별로 어노테이션을 나눠놓은 것
  - service와 repository로 만들어줌
    - 둘다 repository로 만들어도 괜찬다 왜?
    - Component가 그안에 들어가 있다. 그래서 똑같이 객체가 메모리에 뜬다

- 다시 User로 만들어보기
  - 컴포넌트스캔으로 해서 확인해보기



**AOP**

- 관심 분리
- 횡당 관심
- 핵심 관리

- 관점지향 프로그래밍(Aspect Oriented Programming)

- 어렵다

- OOP를 강화시켜주는것, OOP를 대체하는게 절대 아니다

- businessMethod에는 핵심 비지니스 로직은 몇줄되지 않는다

  - Logging 20줄
  - 예외처리 40줄
  - Transaction Handle 30줄
    - 예외발생하면 롤백하고 아니면 푸시해줄거아냐
  - 다시 Logging

- 문제는 

- 핵심 요소는 몇 줄 밖에 안되고 나머지가 너무 많다

  - 응집도가 너무 떨어지는 메소드가 생긴다
  - 응집도는 메소드 이름과 걸맞는 코드로 구현되어있지 않다는뜻
  - 소스 분석이 힘들어진다

- 핵심 관리코드(로직처리), 횡당관리(그외에 부서적기능들)을 분리하자

  - 이게 관심분리
  - 이건 마치 JSP에서 MVC를 적용한 이유와 같다
    - 디자인과 자바로직을 분리 시킨것과 같다
    - 자꾸 분리시켜야 관리하기가 편해진다

  

- AOP프로젝트만들지않고진행

  - log4j.xml 이 없으면 스프링 log가 안보인다
    - appender console을 통해서 찍겠다
    - value 패턴으로 출력한다
    - 콘솔도됮만 파일도 log파일로 출력할 수 있다
    - level(로그레벨) 레벨에 따라서 찍히는 종류가 다르다
      - DEBUG < INFO < WARN < ERROR < FATAL
      - 단계로 구분된다
  - 횡단관심 코드를 분리시킨다
    - 클래스로 구분해서 prinlog를 따로 작성해서 넣어줌
    - 근데 불편한건 객체를 생성해서 넣어줘야하는 불편함있음
      - 클래스가 바뀌는것도 대처가 안됨
      - OOP 언어의 한계
    - 근데이런코드필요없다
  - aop:config는 그렇게 중요하진않다
    - 그안에거는 내일 설명
  - 작성해서 보면 사전처리가 마구 동작한다
    - 나중에 클래스 바꾸더라도 xml만 수정하면된다, LogAdvice -> Log$j로 바꾸면된다
    - 메서드 이름도 바꿔주면된다
      - 이게 aop이다~!
  - 이젠 비지니스 로직은 자기것만 하면된다
    - 만약 이걸 처리하기 어려우면 사다쓰면된다
    - 그래서 공통개발자가 따로있다
  - 왜 service를 한번 거쳐서 dao를 사용할까?
    - dao는 순수하게 db로직만 가지고 있어야한다
      - 그래야 나중에 JPA로 바굴 때 비지니스 로직 바꾸지 않고 DAO만 바꿀수있다
    - 지금은 간단하게 구현해서 그렇지 비지니스로직 중에 DB연동 하지 않는 메소드들도 얼마든지 있을 수 있다
    - 그래서 이런 서비스임플 - dao가 분리가 되었다
  - 돌아와서 AOP는 비지니스 메소드와 횡단관심 메소드의 연결고리가 없다
    - 그래야 횡단관심 메소드만 교체할 수 있다
    - 이건 oop를 뛰어넘는것이다

**AOP 용어 정리**

- 용어만 잘기억하면 된다
- 5개 있는데 2개만 기억해라
  - 포인트컷(Pointcut)
    - 
  - 어드바이스(Advice)
    - 
  - 어스팩트(Aspect)
    - pointcut와 advice를 연결해주는 개념

**내일수업전에 ppt읽고오기**























