# day9

## 수업내용 정리

### SpringAOP

- AOP는 소스상에서 횡단관심과 핵심관리를 분리시키는 것
  - Separation of Concerns라고 한다
- 조인포인트(Joinpoint)
  - 클라이언트가 호출하는 모든 비지니스 메소드를 뜻한다
- 포인트컷
  - 조인포인트 중에서 필요한 메소드에서만 공통 기능 실행할 수있도록 메소드를 필터링 하는 것
  - 트렌젝션이 필요한 메소드와 그렇지 않은 메소드를 구분할때 같은 상황에서 필터링이 필요하다
    - 트랜젝션
      - SQL에서 Insert하면 바로 Insert되는게 아닌 DB에 구문이 쌓였다가 커밋을 해야 DB에 반영이된다
      - 트랙젝션을 하는 이유
        - 1) 이렇게 적용하는 것이 하나하나 반영하는 것보다 빠르다
        - 2) 계좌이체 같이 2개의 계좌를 모두 업데이트하는 것이 하나의 거래가 될 때가 있다
        - 이럴때 2개의 거래를 묶어서 둘다 성공시 커밋하고 실패시 롤백하는 트랜젝션이 필요하게 된다
      - 검색 기능은 DB에 내용에 영향을 주지 않기 때문에 트랜잭션이 필요가 없다
  - 실습
    - 포인트 컷을 하나씩 수정해 보며 각부분이 어떤 역할하는지 알아가는 실습을 하였다
      - 포인트컷 표현식은 리턴 타입, 패키지 경로, 클래스명, 메소드명 및 매개 변수를 설정할 수 있다
      - 포인트컷을 하나더 만들어 apsect에 교체해서 실행해보는 실습을함
- 어드바이스
  - 횡단 관심에 해당하는 공통 기능의 코드
    - 보통 메소드로 구현이 되고 구현에 따라 내용이 달라진다
  - 동작시점 5개
    - 필요에 따라 메소드의 실행시점을 달리할 수 있다
    - Before : 비지니스 메소드 전에 실행 된다
    - After : 비지니스 메소드 후에 실행 된다
    - After-returning : 비지니스 메소드의 returnig을 받은후에 실행 된다
    - After-throwing : 비지니스 메소드의 예외객체를 받은 후에 실행 된다
    - Around : 비지니스 전 후에 실행 된다
- 어스팩트(Aspect) 또는 어드바이저(Advisor)
  - 포인트컷과 어드바이스의 결합이다
    - 어스팩트 설정에 따라 AOP 동작 방식이 결정되기 때문에 가장 중요하다
  - 스프링에서는 어스팩트와 어드바이저를 둘다 사용한다
  - 해석순서를 이해해야 한다
    - 포인트컷을 받고 수행시점을 받고 수행하는 클래스를 받고 수행하는 메소드를 받는다
  - 실습
    - After + After-returning 실습
      - After는 비지니스메서드 실행후에 실행된다
      - After-returning은 returning 속성에 이름을 가진 매개변수에 비지니스 메소드의 return을 받아서 넣어준다
      - 받은 retrun 값은 사후처리 메소드에서 활용하여 사용한다
        - retrun값을 활용하기 때문에 retrun값이 있는 메소드만 실행될수있도록 getpointcut을 활용해야 한다
    - After-Throwing실습
      - 예외가 발생했을때 실행할 공동 메서드이다
      - 비지니스 메서드의 예외 객체를 throwing 속성에 exceptionObj 에 담아 파라미터러 넣어주어 예외를 분기처리하게 된다
    - Around
      - 사전 사후처리를 동시에 하는 기능이다
      - param으로 ProceedingJoinPoint를 받고 return은 Object로 해주어야 한다
      - jp.proceed를 통해 비지니스메소드를 실행시키고 그결과값은 Object로 받아주어 후처리 후 return한다
        - void메서드의 경우 return에 갑이 담기지 않지만 클라이언트에서 그값을 활용하지 않기 때문에 문제가 발생하지 않는다
      - StopWatch를 활용해 전후 메서드를 사용해서 수행 속도를 측정하는 실습을 하였다
    - 모두 어노테이션으로 바꾸기
      - 공통 기능 클래스로 가서 @Service와 @Aspect 어노테이션을 달아준다
      - @pointcut 어노테이션을 단 pointcut메서드를 만든다
      - 동작을 수행하는 메서드 위에 @Before, @After 등 시점을 선언하는 어노테이션을 달아주고 괄호()에 pointcut 메소드 명을 넣어준다
        - 필요에 따라 pointcut 속성과 returning, throwing 속성을 활용해준다
    - 포인트컷 합쳐서 적용하기
      - pointcut을 하나의 클래스로 모은뒤 각각의 advice에서 클래스명.포인트컷 명으로 참조하여 사용하는 실습을 하였다
      - 포인트컷이 다양해질때 중복 선언하는 것을 방지해주는 유용한 기능같다
    - JoinPoint를 통해 비지니스 메소드 정보 가져오기
      - Advice 메소드에 파라미터에 Joinpoint jp를 가져오면 비지니스 메소드의 정보를 가져올 수 있다
        - Joipoint 객체를 생성해서 넣어주는것은 스프링 컨테이너의 역할이다
        - 마치 HtppServletRequest를 넣어준 것과 같다
      - Around의 경우는 이미 선언된 ProceedingJoinPoint를 사용해야 하며 이는 Joinpoint의 자식 클래스이다
        - 하지만 다른 클래스에서 ProceedingJoinPoint를 사용할 수 없게 되어 있다.
        - Around는 혼자만 특별한 규칙들이 존재해 따로 기억해주어야 될 것 같다
  - 정리
    - Advice객체를 호출하고 JoinPoint 객체를 생성해서 넣어주는 것은 스프링 컨테이너가 해준다
      - 우리는 컨테이너가 제공해주는 객체를 통해 어떻게 구현을 할것인가를 고민하면 된다
    - AOP뿐만 아니라 앞으로 프레임워크를 배우는 과정에서도 프레임워크가 제공해주는 영역들을 알고 그것들을 활용해서 우리가 필요한 서비스를 어떻게 구현할지를 배우는게 목표이다.



### Spring JDBC

- DB연동하는 DAO 구현을 획기적으로 줄여주는 기능
  - 우리가 수동으로하던 구현을 Spring이 내부적으로 해주는 것임을 이해하고 있어야 한다
- 실습
  - 기존에 DAO를 Srping JDBC가 적용된 DAO로 변경하는 실습
  - JDBCTemplete 객체를 변수로 선언하고 객체.update("SQL문")메서드를 통해 insert, update, delete에 모든 코드들을 대체할 수 있었다
    - ?로 입력받는 Statement에 값들도 SQL문 옆에 콤마(,)로 구분하여 arguments로 입력해주면 된다



## 수업 중 기록한 내용



**어제수업**

- AOP
  - 소스상에서 횡단관심과 핵심관심을 완전히 분리시키자
    - Separation of Concerns
  - 횡단 관심
  - 핵심관심
    - 99%는 이것을 개발하는일을 한다



- 조인포인트

  - 클라이언트가 호출하는 모든비지니스 메소드

  - 포인트컷

    - 조인포인트 중에서 필터링한 것

    - 필터링된 비지니스 메소드를 포인트컷이라고 한다

    - 왜 필터링?

      - 인설트 업데이트는 트랜잭션하고 셀렉트메소드는 트랜잭션 안하고 싶은거야
      - 반대로 셀렉트만 로그를 출력하고 싶을 수 도있다
      - 다시말하면 원하는 메소드에서만 공통 기능이 동작하도록 하기
  - 
  
- 트랜젝션
  
  - 인설트하면 바로 인설트가되는게 아님
    - DB에 구문이 쌓인다
  - 커밋이라는 sql 명령어실행해야 반영이된다
      - 왜이짓을하냐? 느리다
      - 입력수정삭제를 한다고해서 실제 db에 반영되는 것은 아니다
    - 계좌이체를 생각하면
      - 인출,입금 둘다 다해야된다
      - update 2번했는데 하나라도 실패하면 어떻게해야되?
        - rollback해야되.
      - 둘다 성공하면 commit해서  반영을해야한다
    - 트랜젝션은 commit과 rollback이 되야 끝난다
      - 하나의 논리적인 작업단위
      - 입력수정삭제 입력이 되면 트랜젝션시작되고 커밋or롤백해야 트랜잭선 종료된다
    - 데이터와상관없는 Select는 상관이없다 
  
- 실습
  - 포인트컷 - 원하는 메서드만 부가기능 실행되도록하겠다
    - *을 void로 바꾸기
      - return 타입이 void인 메서드에서만 사전처리 작동
    - !*은 void가 아닌 타입 메서드
    - *은 모든 메서드가 사전처리된다

- execution은 명시자라고 부르는데 중요하지 않고 중요한건 ((* com.rubypaper.biz..*Impl.*(..)))쪽에 것을 포인트컷 표현식이라고 부른다
  - 필터링 결과가 달라진다
  - 리턴 타입, 패키지 경로, 클래스명, 메소드명 및 매개 변수 만 있으면 걸러낼수있다
  - 리턴타입
    - *, void, !void 3가지 혹은 디테일하게 클래스패스+클래스명으로 특정클래스 지정할수도있다
  - 패키지경로
    - 한칸 빈칸띠고
    - 1)..으로 끝나면 요패키지로 시작하는 모든 패키지
    - 2) 디테일하게 패키지지정, 
    - 3) ~~로 시작하고 ~로 끝나는 패키지
      -  com.rubypaper..user com.rubypaper로시작하고 user로 끝나는 패키지
      - 우리는 biz하나있다
  - 클래스명
    - 디테일하게 지정할수있고(아스테리크 활용)
    - *ServiceImpl 이렇게 범위로 할수도있고
    - 클래스는 대소문자를 구분해야한다
  - 메소드명
    - 아스테리크적절히 활용한다
    - get*은 get~메소드
  - 매개변수
    - 100%(..) 타입과 갯수무시해라
    - (in, double) 이런식으로 지정할 수도 있다.
      - 매개변수까지 필터링하는 경우는 거의 없다
  - 실습
    - getPoincut 하나더만들어서 pintcut-ref에 id를 바꾸어서 넣어보기
  - delete board

**어드바이스**

- 횡단 관심에 해당하는 공통의 기능의 코드
  - 보통 메소드로 구현이 된다
  - method=printlog가 메소드 LogAdvice.pringLog()가 어드바이스메소드
  - 구현에 따라 달라지게 된다
- 동작시점 5가지로 지정
  - 왜 5가지로 구성?
    - 필요에따라 메소드의 실행시점이 달라진다
    - 내가 메소드에 동작시점을 결정할 수 있어야한다
  - <aop:before 에 해당하는 것이엇음
  - 5가지 시점
    - @Before : 작업 시작전에
    - 
    - @After : 작업이 끝난후에



**위빙**

패스함



**어스팩트(Aspect) 또는 어드바이저(Advisor)**

- 포인트컷과 어드바이스의 결합
- 어스팩트 설정에 따라 AOP 동작 방식이 결정되기에 가장 중요하다
- 스프링에서만 어스팩트, 어드바이저 둘다 사용한다
- <aop:aspect가 어스팩트다
- 해석순서를 외워야 한다
  - 어스팩트는 pintcut과 + Adivise에 하벼졋다
  - pointcut은 핵심관심 이고 Advise는 횡단관심이다.
  - Aspect는 두개를 연결해준 것이다
  - 따라서 아무리 어드바이스를 잘만들어놔도 포인트컷을 잘만드러놔도 어스팩트로 연결을 하지 않으면 도앚ㄱ하지 않는다
  - 컨테이너야 포인트컷 이 실행된 후에(전에) 요객체가 가지고 있는 요메서드를 실행해
  - pointcut-ref -> :after -> ref -> method 순으로 하면된다

- 실습 - 사후처리 만들기
  
  - 똑같이하면됨 afterLog로
- 실습- afterLog로 비지니스결과값으로 하고 싶다
  - 근데 after는 retunig 속성을 쓸수가 없다
  - after-returning으로바꾸어야함
    - retuning="returnObj"작성
    - 컨테이너야 너는 겟 머머 실행하고 return해주면 returng후에 method에 매개변수에 returnObj를 넣어줘
      - 매개변수이름과 return 이름이 같아야 한다
      - 뭘리턴할지 몰라서 Object타입으로 한다
    - 왜 이짓을할까
      - 클라이언트가 재고목록 요청하면 재고목록을 줄수있지
        - 근데 나는 리턴도하고 다른 db에도 저장하고 싶은거야
        - 중요한건 비지니스메소드를 건들지 않고
      - 혹은 롤이 어드민인사람에게 새로운 것을 제공하고 싶은거야
        - Role이 ADMIN이 라면 관리자화면으로 보내기 같은 기능
  - after와 after-returning의 차이를 알야 한다
    - return을 받을수 있느냐 없느냐의 차이이다.
- AfterThrowingAdvice해보기
  - 모든 예외를 Exception으로 받아서 분기처리해버림
  - IllegaArguemntException
    - 입력값에 대해서 어떤 반응을 보여주고싶을때
    - 잔액을 0으로입력할수 없다든지, -0번글응 입력을못한다던지
  - aop 작성
    - returning대신에 throwing작성하고 매개변수 명을 복사해서(exceptionLog에서) 붙여넣는게 안전하다
  - 예외가 발생했을때만 이 메서드가 실행된다
  - 발생한 예외객체를 매개변수를 넣어주어라
  - 실행시 예외 발생.

- 마지막 **Around**남았다

  - 사전, 사후 , 예외 처리가 나왔는데 마지막은 사전 사후처리 모두 가능

  - aroundLog에 return은 절대로 Object여야 되고 매개변수도 ProceedingJoinPoint jp으로 정해져있다

    - 만약 return이 void인 메서드가 실행되서 obj에 null이 담겨도 클라이언트에서 해당 return을 활용안하니 문제가 되지 않는다

      

  - 서브릿 필터와 비슷, 얘는 비지니스 로직에 사전후처리라는것만 다르다

  - aop 등록 

    - bean대신 컴포넌트쓰기
    - 컴포넌트id를 ref에 넣어주기

  - around로 등록하면 pointcut에 해당하는 메서드실행하기전에 사전사후 로 실행시켜라

    - pj.proceed를 실행하고 return값을 obj로 넘겨주고 그다음에 after로 넘겨주고 마지막에 obj return한다

  - 만약 return이 void이면 클라이언트가 바보가됨

  - proceed를 안실행시키면 null이 리턴됬다

  - stopwatch로 실행해보기

    - 

- 여기까지가 aop핵심내용

- 지금부터는 어노테이션으로 구현하기

  - aop도 ioc같이 어노테이션+xml설정으로 구현한다
  - 빈등록과 aop설정 모두 주석처리
  - \<aop:aspectj-autoproxy/> 얘만 등록하면 설정끝

- logAdvice가서 어노테이션 등록

  - advice는 있으니 pointcut만 등록하면된다

    - 메서드인데 바디가 없고 뭘 적용해도 뭐가안된다
    - 왜나면 어노테이션으로 부른건 호출한게 아니기 때문에
    - 이런 메소드를 **참조용메소드** 라고 한다
      - 마치 식별자 처럼 구분하려고
    - 포인트컷을 어노테이션으로 작성시 어노테이션들을 구분할 방법이없다
      - 그래서 바디가 없는 메소드로 구분자로 사용하기로 했다

  - 어노테이션으로 ""에 그거 표현식넣어줌

    - 그리고 Before에 point컷을 연결해줌

  - 왜 어노테이션으로 하냐?

    - @Service를 주석으로 막으면 사전처리 막을수있음

    - 메소드이름이바뀌어도 실행이 잘됨

      - xml에 등록을 안했기 때문에

      

- around도 어노테이션으로 해보기
  
  - service에 id는 지워주기 -> ref를 안하기때문에 xml에서
- 어노테이션이 

- After는 리턴지정해주어야한다
  - 어노테이션에  poincut과 returning 속성 추가한다
  - !void 하거나 get*을하거나 해주어야하지
  - 두그룹으로 나눈다. 서비스 임플하고 공통개발자가 나뉜다

- 포인트 합치기
  
- 4개로만들어서 적용
  
- 사전처리 전에 어떤메소드가 실행되는지 알아야됨
  - jp를 하고 jp.getSignature().getname하면 메소드이름알수있음
    - siantgure.toLongString을 하면 모든 정보를 다알려줌
    - toshortSTring은 간단하게 알려줌
  - getArgs()하면 Args를 배열로 받아볼수가 있다
    - 산저리에서 그 args를 활용할수있다는 뜻
- 예외메소드가 어떤건지찾을필요가잇음
  
  - getname 복사해서 가져가서 첫번째 param으로 jp만듬
- joinpoint가 이래서 중요하다. 
  
  - 어떤메소드에서 예외발생했는지, args가먼지알수있다
- Around에서 적용
  - param에 Joinpoint아니라 ProceedingJoinPoin를 사용해야한다
    - 그래야 proceed를 사용할수 있다
    - ProceedingJoinpoint가 Joinpoin를 상속한다
      - 근데 다른데서는 못쓰고 오직 Around에서만 사용할 수 있다
      - 다른데서는 Joinpoint를 써야한다
        - 왜그런지 모른다, 어떻게도 모른다

- printLog는 누가 호출해? 스프링 컨테이너가 하지
  - Joinpoint 객체는 누가 넣어줘? 컨테이너가 넣어주겠지
    - 서블릿에서 request넣어주듯이 jp도 값을 많이넣어서 준다
    - 이런 컨테이너의 개념은 앞으로도 똑~같~다~
- 프레임워크를 사용할때 제일 중요한것
  - 프레임워크가 어디까지 해주고 내가 어디까지해야되는지 아는 것
    - 프레임웤이 발전할수록 개발자가 바보가된다.
      - 너무많은것들을 프레임웤이 해주기때문에 그렇다
      - 180줄자리 소스를 컨테이너도움받아서 10줄로줄일수있다
    - 소스가 계속 줄어든다. 누군가는 해주는건데 그걸 프레임웤이 해준다
    - 우리가하는건 컨테이너가 넣어준 객체를 활용해서 메서드를 구현하는것(우리가 필요한 서비스의 모습으로)
      - 서블릿에서도 그랬고 지금 aop에서도 그랬다

AOP 끝!

내일할것

Spring JDBC

- DB연동을 자바코드한줄로할수있다
  - 스프링쪽에서 많은걸해주는데 그걸 이해하면 된다

- BoardDAO 복사해서 BoadDAOSpring을 만들어준다
  - 정말 기본적인것만 남기고 다지운다
  - JdbcTemplate 변수만들고 @Autowired 붙여줌
    - 객체를 하나생성해줘야되는데 내가만들지 않은 클래스기 때문에 bean등록해야됨
      - 컴포넌트를 붙여주자나
    - or MyjdbcTemplate 클래스만들어서 상속해서 @repository를 붙일수도 있음
- spring.updated하나로 모든걸 다할수있다...
  - SQL문만 넣어주면 된다...wow
  - SQL문에 ?은 어떻게 하지?
    - SQL문 옆에 argument로 ,로 구분해서 순서대로 넣어주기만 하면 된다



























