# day17

엔티티가 무엇?

- 엔티티는 테이블에 저장된 하나의 데이터 매핑된 자바객체 의미
  - VO 객체를 인티티라고 생각해도 무관하다
- @Entity가 붙은것을 엔티티라고한다



엔티티 매니저 팩토리

- 엔티티를 관리하려면 엔티티 매니저가 필요하다
- 엔티티매니저 생성하려면 엔티티 매니저 팩토리가 필요하다

엔티티매니저

- 엔티티매니저를 통해 엔티티를 관리(등록, 수정, 삭제, 조회) 할 수 있다
  - CRUD기능을 구현하려면 엔티티매니저가 필요하다

엔티티 매니저 생성 과정

- 2번 퍼시스턴스 클래스를 통해 엔티티 매니저 공장을 만들 수 있다
  - 1번 퍼시스턴스 클래스에서 메인환경설정 파일(persistenc.xml)을 로딩해준다
  - 3번 엔티티 매니저 팩토리에서 인티티매니저를 얻을 수 있다(여러개를 얻을 수 있는거지 공장에서)

JPA 기반의 애플리케이션 개발 순서

- 엔티티 매니저 팩토리 생성
- 에닡티 매니저 생성
- 트랙잭션 시작(트랜잭션 안에서 진행해야한다) 
  - 비지니스 로직(CURD)처리 (Slect는 불필요)
- 트랜잭션 종료
- 클로우즈

영속성 컨텍스트(= JPA 컨테이너)

- 엔티티 매니저 생성할때 영속 컨텍스트도 같이 생성된다
  - 엔티티 매니저 객체를 이용하여 영속 컨테이너로 접근할 수 잇따
    - 그래서 엔티티매니저 = 영속 컨테이너라고 부른다

엔티티 생명주기(4가지 상태)

- 비영속 : 객체를 생성만 한 상태, 아직 persist()안한 엔티티 객체

- 영속 :  persis(), find()메소드로 영속상태로 바꿀수 있다. 바로 Insert가 되지는 않는다

  - tx가 종료(commit)되지 않으면 insert하지 않는다 (상태는 영속한것 맞나?)

- 준영속 : 영속상태에 있던 객체가 jpa컨테이너에 통제에서 벗어나는것

  - 들어갔다가 나온게 중요, 안들어간것은 비영속 상태(왜이렇게 구분하는지 궁금하다)

  - 들어간적이 없는것, 식별자 변수에 값이 할당되지 않는것이 비영속상태와의 차이점이다

    - 영속상태로 바뀔때(persis()) seq값이 할당되기 때문이다(준영속 상태만 프라이머리 키값을 가지고있다)

  - detach(), close(), clear()메소드가 실행됬을때 비영속 상태가 된다

    - detach

    - closee() : 컨텍스트를 종료하는것, 그때 엔티티 객체를 모두 내보낸다

    - clear(): 엔티티 객체들을 모두 비워버린다, 하지만 컨테이너가 종료되는것은 아니다

      

- 삭제  : remove() 해당 객체를 없에고 db에서도 삭제한다

엔티티 생명주기(2)

- 업데이트도 트랙젝션이 종료될때 같이 실행된다(우리가 따로실행은 하지 않아도)
- 준영속 상태에 객체는 아무리 값을 바꾸어도 업데이트로 이어지지 않고 merge() 메소드 통해 다시 영속상태로 돌아오면 그때 값이 테이블에 업데이트된다
  - 업데이트 상태 값을 바꿀때 업데이트
  - 준영속상태 값바꾸고 merge()할대 업데이트
- remvoe 하면 객체 삭제하고  db에서도 delete한다



## 영속성 컨테스트 특징

JPA컨테이너는 복잡해서 잘이해해야 한다



### 영속성 컨테스트의 식별자 값

- 식별자 변수는 프라이머리 ㅋㅣ와 연결되 변수
- @id 붙은 변수
- 영속상태에 객체는 구별을 위해 반드시 식별자 값이 있어야 되고* *없으면 예외발생한다**
- @Generatevalue라는 어노테이션통해 식별자 변수에 자동으로 +1씩 증가시킨다



### 영속성 컨텍스트에 사용의 장점

- 1차 캐시 : Map 과 같은 저장소가 있다
  - 비영속 객체를 persist()하면 1차캐시에 @id와 Entity 쌍으로 저장한다, 
    - 그래서 unique한 키값이 중요하다! => @id로 세팅한 식별자 변수이다 
  - Find()했을때는 1차캐시에 이값이 있으면 db Selection없이 key값으로 value받아서 리턴해준다
    - 만약 1차 캐시에 값이 없다면 DB를 Select해서 엔티티 값을 생성해서 값을 채우고 1차캐시를 채우고 클라이언트로 리턴한다
    - 이렇게 함으로 쓸데없는 DB연결을 줄인다
      - 이래서 JPA 성능이 좋다! OH!

- 영속 엔티티의 동일성 보장
  - 아무리 값을 여러번 불러와도 매번 똑같은 객체가 리턴된다(캐쉬에 있는 객체 계속 돌려주는것)
    - 스프링 컨테이너와 느낌이 비슷하다. getBean 아무리 많이해도 하나의 객체에 주소만 리턴해주는것과 같은 이치다
- 엔티티 등록
  - entity를 persist()하면 동시에 2가지 일을 한다
    - SQL 저장소에 Insert 명령어 작성해서 SQl 저장소에 저장
    - 1차 캐시 등록
  - 다른 entity persit()하면 똑같은 2가지일을 반복
  - tx.commit하는 순간 쌓여있던 SQL 저장소에 SQL문이 한번에 실행된다
    - 이것을 Flush()라고 하고 tx.commit과 동시에 일어난다 (flush 이후에 commit)
    - 아무리 persist()많이해도 commit하지 않은 DB에 반영되지 않는다

쓰기 지연과 플러시

- 이러헥 하는 이유가 뭘까?
- 한번에 DB연동으로 여러 명령을 동시에 처리하겠다 => 성능이 좋을 수 밖에 없다



### 엔티티 수정

- 모든 컬럼을 수정하는것을 기본으로 한다
  - @colum(updatable=false)만 빼고 모든것을 수정한다
  - 경우에 수가 너무 많기 때문에 그냥한다
  - 이때 똑같은 쿼리문을 사용하면 더 빠르게 사용할 수 있어서 성능에 도움이 된다
    - PreaprdStatement 사용하는게 sTatemnet보다 빠른이유

    - ?로채워서 미리 띄워놓기 때문에 훨씬빠르다

      
- 트랜잭션 시작
  - find해서 memberA를 찾음
    - 있다면 1차캐쉬 반환, 없으면 slect해서 1차캐쉬 채워서 반환
  - 그리고 1차캐쉬에 등록되어있는 객체를 수정해야 update가 일어난다
    - tx.종료되어있을때 1차캐쉬에 상태를 보고 update를 하는 것이다
- 마지막으로 **스냅샷**이 등장
  - 1차캐쉬 오른쪽에 스냅샷이 존재한다(스냅샷은 사진이다)
  - 1차캐쉬에 객체가 들어올때 컨테이너가 스냅샷찍듯 복제해서 스냅샷에 저장한다
    - 똑같은 상태에 객체가 메모리에 2개떠잇는것
  - 그다음에 1차캐시에 있는 entity를 고치고 commit 하는 순간 컨테이너가 1차캐쉬에 객체와 스냅샷을 비교한다
    - 고친 객체는 두객체를 비교해서 같은 값은 그대로 복사하고 다른값만 update SQL 만든다
      - 업데이트된 상태에 스냅샷으로 객체가 교체된다
      - 그리고 다른 SQL문과 함께 같이 flush되고 commit된다
    - 안고친 객체는 update에서 제외시킨다
- 스냅샷은 등록삭제와는 상관없이 수정할때만 의미가 있다
- 엔티티 수정에서는 모든 필드 수정이다
  
  - 그래야 preaparestatement생성한것 처럼 항상 동일한 객체를 보낼수 있다
- 삭제는 sql문이 쌓여서 flush될때 될것이다

플러시

- 컨테이너가 가지는 엔티티에 변경사항을 db에 반영하는 과정
- 플러시가 됬을대 먼저 스냅샷과 비교해서 업데이트 sql문 작성저장하고, 저장소에있는 sql문들을 한번에 db쪽으로 전송해준다

### 준영속

- detach는 하나의 엔티티만 준영속 상태로 만든다
  - 한번 영속상태에 있다가 영속성 컨텍스트가 더이상 관리하지 앟는 사앹를 준영속 상태라고 한다.



## springboot로 넘어가기

<dependency>
		<groupId>junit</groupId>
		<artifactId>junit</artifactId>
	</dependency>

## DataSource Setting 
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
spring.datasource.password=

## JPA Setting 
spring.jpa.hibernate.ddl-auto=create
spring.jpa.generate-ddl=false
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.properties.hibernate.format_sql=true

## JPA Logging Setting

logging.level.org.hibernate=info

==> 프로프터 ㅣ설정 쉽게할수있게 해준다





- spring-boot-starter-data-jpa 통해서디펜던시 쉽게 추가했고 스프링 부트가 enalbeAUto를 통해서 jap 관련 객체를 띄워준다
  - 좀더 쉽게 jpa사용할수이쓴ㄴ 환경이 되었다

ch05 피피티

public interface BoardRepository extends CrudRepository<Board, Long>{ 엔티티이름/ 식별자 변수 타입

- 이렇게 만들면 구현한 클래스를 자동으로 내부적으로 만들어준다.
  - crcd 레파지토리만 상속하면 쉽게 작성할 수 있다!
  - Board entity를 사용한 crud를 만들수 있다

- package com.rubypaepr;

  public class BoardRepositoryTest {

  } 작성

  - 테스트 케이스 작성
  - 오터와이어드로 객체생성

- 웹개발에서 페이징 처리가 중요하다
  - 페이저블 객체가 필요하다
  - 근데 더나아가서 page라는 객체가 존재한다 - 그걸이용해보자
  - 리턴을 List를 Page로만 바꿔주면된다

- 정리
  
  - ppt에 쿼리 메소드 유형이 있다



@Query 어노테이션

- JPQL을 활용하는 것
  - SQL이랑은 달라서 부담스러우면 그냥 쿼리메소드를 사용하라
  - 메소드이름이 너무 길어져서 싫다면 JPQL을 직접이용하는 방법도 있다
- ​	@Query("SELECT b FROM Board AS b WHERE b.title like %?1% ORDER BY b.seq DESC") //From뒤에 엔티티클래스이름이 온다(대소문자구분)
  - From 뒤에 엔티티클래스 이름넣고 AS알리아스 하기 (AS는 생략가능)
  - b가 알리아스라고 한다. 그럼 b를 Select라는 것은 board 객체를 검색해라
  - where.b.tille like %?1%  ?1은 파라미터 1번
  - b.seq
- 일반적인 sQl문과 비슷하지만 엔티티객체를 대상으로 검색한다는게 다르다
  - 검색을 하게되면 검색 대상이 모두 1차캐쉬로 다 등록이 되서 검색이 실행된다 (1차 캐쉬에 없으면 검색이 안된다)
    - 만건에 데이터중 모두를 선택하면 만건에 데이터가 컨테이너에 1차캐쉬안에 엔티티 만개가 올라간다 => 메모리사용량이 많다
    - 그래서 성능 향상을 위한 여러 장치들이 필요하다
  - JPQl은 실제로 SQL로 변환되서 작동한다
    - jsp를 작성하여 실행하면  서블릿으로 변환되서 사용되는 것처럼 JPQL을 작성하면 SQl로 변환하여 실행하게 된다



- **annotation2 해야함**
  - Ojbect row가 먼지 알아야함 => 변수 결과를 object[]에 넣은거 같은데



### 연관관계 매핑

어렵지만 재밌다





마지막에 멤버파일 안들어가는거확인하기



























